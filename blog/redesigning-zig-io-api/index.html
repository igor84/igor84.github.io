<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.105.0"><meta name=generator content="Relearn 4.1.0+tip"><meta name=description content><title>Redesigning Zig IO Api :: Dr Iggy's Coding Adventures</title><link rel=alternate type=application/rss+xml href=/blog/redesigning-zig-io-api/index.xml title="Dr Iggy's Coding Adventures"><link rel=icon href=/images/favicon.svg?1667939627 type=image/svg+xml><link href=/css/nucleus.css?1667939627 rel=stylesheet><link href=/css/fontawesome-all.min.css?1667939627 rel=stylesheet><link href=/css/featherlight.min.css?1667939627 rel=stylesheet><link href=/css/auto-complete.css?1667939627 rel=stylesheet><link href=/css/theme.css?1667939627 rel=stylesheet><link href=/css/theme-relearn-dark.css?1667939627 rel=stylesheet id=variant-style><link href=/css/variant.css?1667939627 rel=stylesheet><link href=/css/print.css?1667939627 rel=stylesheet media=print><link href=/css/custom.css?1667939627 rel=stylesheet><script src=/js/variant.js?1667939627></script>
<script>var index_url="/index.json",baseUriFull,root_url="/",baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="Copy to clipboard",window.T_Copied_to_clipboard="Copied to clipboard!",window.T_Copy_link_to_clipboard="Copy link to clipboard",window.T_Link_copied_to_clipboard="Copied link to clipboard!",baseUriFull="https://igor84.github.io/",variants.init(["relearn-dark","neon","relearn-light"])</script><script src=/js/jquery.min.js?1667939627></script></head><body class=mobile-support data-url=/blog/redesigning-zig-io-api/><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable><div><div class=navigation><span class="nav nav-next"><i class="fa fa-chevron-right fa-fw"></i></span></div><div class=navigation><a class="nav nav-prev" href=/blog/ title="Blog (&#129104;)"><i class="fas fa-chevron-left fa-fw"></i></a></div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle title='Menu (CTRL+ALT+m)'><i class="fas fa-bars fa-fw"></i></a></span>
<span id=toc-menu title='Table of Contents (CTRL+ALT+t)'><i class="fas fa-list-alt fa-fw"></i></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><meta itemprop=itemListOrder content="Descending"><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="3"><a itemprop=item href=/><span itemprop=name>Dr Iggy's Coding Adventures</span></a> ></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="2"><a itemprop=item href=/blog/><span itemprop=name>Blog</span></a> ></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="1"><a itemprop=item href=/blog/redesigning-zig-io-api/ aria-disabled=true><span itemprop=name>Redesigning Zig IO Api</span></a></li></ol></div><div class="default-animation progress"><div class=wrapper><nav id=TableOfContents><ul><li><a href=#current-zig-io-api>Current Zig IO API</a><ul><li><a href=#reader-and-writer>Reader and Writer</a></li><li><a href=#streamsource>StreamSource</a></li></ul></li><li><a href=#analysis>Analysis</a></li><li><a href=#alternatives>Alternatives</a><ul><li><a href=#1-just-make-seekablestream-a-part-of-reader-and-writer>1. Just make <code>SeekableStream</code> a part of <code>Reader</code> and <code>Writer</code></a></li><li><a href=#2-use-vtable-interface-like-allocator>2. Use VTable interface like Allocator</a></li><li><a href=#3-make-streams-be-readers-and-writers-using-mixins>3. Make streams be Readers and Writers using mixins</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></div></div></nav><main id=body-inner class=highlightable tabindex=-1><div class=flex-block-wrapper><div id=head-tags><div class=tags><a class=tag-link href=/tags/memory>memory</a>
<a class=tag-link href=/tags/programming>programming</a>
<a class=tag-link href=/tags/zig>zig</a></div></div><article><h1>Redesigning Zig IO Api</h1><p>Input-output being one of the most fundamental systems in any programming language was probably one
of the first that was designed in Zig&rsquo;s standard library. As Zig grew and gained additional features
it had a few redesigns but it is still not without issues so here I want to analyze how it is
currently implemented and if we can now do better.</p><div class="box notices cstyle note"><div class=box-label><i class="fa-fw fas fa-exclamation-circle"></i> Note</div><div class=box-content><p>There are additional language improvement proposals aiming to improve this exact area like
<a href=https://github.com/ziglang/zig/issues/1268 title="comptime interfaces">this</a> and
<a href=https://github.com/ziglang/zig/issues/10184 title="std.interface - better polymorphism support in
standard library">this</a> but here I will only present what can be done with Zig today.</p></div></div><h2 id=current-zig-io-api>Current Zig IO API</h2><p>We will start at the lowest level with <code>std.fs.File</code> representing a file on the file system and
<code>std.net.Stream</code> representing a network stream. Both of these have the following methods:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=k>fn</span><span class=w> </span><span class=n>read</span><span class=p>(</span><span class=n>self</span><span class=p>,</span><span class=w> </span><span class=n>buffer</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=n>Error</span><span class=o>!</span><span class=kt>u64</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span><span class=w> </span><span class=n>write</span><span class=p>(</span><span class=n>self</span><span class=p>,</span><span class=w> </span><span class=n>buffer</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=n>Error</span><span class=o>!</span><span class=kt>u64</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>They also have a <code>close()</code> method and methods to fetch their <code>Reader</code> and <code>Writer</code> objects which we
will explain later. <code>File</code> also has a lot of other methods that only make sense for a File but not
for a network stream. One set of such methods, that are of interest, are seeking methods and a
method to fetch a <code>SeekableStream</code> from a File. They are:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=k>fn</span><span class=w> </span><span class=n>getEndPos</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=n>File</span><span class=p>)</span><span class=w> </span><span class=n>GetSeekPosError</span><span class=o>!</span><span class=kt>u64</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span><span class=w> </span><span class=n>getPos</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=n>File</span><span class=p>)</span><span class=w> </span><span class=n>GetSeekPosError</span><span class=o>!</span><span class=kt>u64</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span><span class=w> </span><span class=n>seekBy</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=n>File</span><span class=p>,</span><span class=w> </span><span class=n>offset</span><span class=o>:</span><span class=w> </span><span class=kt>i64</span><span class=p>)</span><span class=w> </span><span class=n>SeekError</span><span class=o>!</span><span class=kt>void</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span><span class=w> </span><span class=n>seekTo</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=n>File</span><span class=p>,</span><span class=w> </span><span class=n>offset</span><span class=o>:</span><span class=w> </span><span class=kt>i64</span><span class=p>)</span><span class=w> </span><span class=n>SeekError</span><span class=o>!</span><span class=kt>void</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>std.io.SeekableStream</code> is a generic struct that contains a pointer to the original stream and those
seekable methods that just call those same methods on that original stream. That way it acts as a
sort of interface. <code>File</code>, of course, defines its own instance of this type so that the pointer in
that instance is of type <code>*File</code> and same goes for <code>std.net.Stream</code>.</p><h3 id=reader-and-writer>Reader and Writer</h3><p><code>std.io.Reader</code> and <code>std.io.Writer</code> are also generic structs that contain a pointer to original
stream but besides wrapping the <code>read()</code> and <code>write()</code> methods respectively they also provide
additional methods, or, in other words, additional behavior. Some examples for Reader are:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=k>fn</span><span class=w> </span><span class=n>readByte</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=nb>@This</span><span class=p>())</span><span class=w> </span><span class=o>!</span><span class=kt>u8</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span><span class=w> </span><span class=n>readInt</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=nb>@This</span><span class=p>(),</span><span class=w> </span><span class=kr>comptime</span><span class=w> </span><span class=n>T</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>,</span><span class=w> </span><span class=n>endian</span><span class=o>:</span><span class=w> </span><span class=n>anytype</span><span class=p>)</span><span class=w> </span><span class=n>anytype</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span><span class=w> </span><span class=n>readStruct</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=nb>@This</span><span class=p>(),</span><span class=w> </span><span class=kr>comptime</span><span class=w> </span><span class=n>T</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=n>anytype</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span><span class=w> </span><span class=n>readUntilDelimiter</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=nb>@This</span><span class=p>(),</span><span class=w> </span><span class=n>buf</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>delimiter</span><span class=o>:</span><span class=w> </span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=o>!</span><span class=p>[]</span><span class=kt>u8</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>And some examples for Writer are:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=k>fn</span><span class=w> </span><span class=n>print</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=nb>@This</span><span class=p>(),</span><span class=w> </span><span class=kr>comptime</span><span class=w> </span><span class=n>format</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>args</span><span class=o>:</span><span class=w> </span><span class=n>anytype</span><span class=p>)</span><span class=w> </span><span class=n>anytype</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span><span class=w> </span><span class=n>writeByte</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=nb>@This</span><span class=p>(),</span><span class=w> </span><span class=n>byte</span><span class=o>:</span><span class=w> </span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=o>!</span><span class=kt>void</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span><span class=w> </span><span class=n>writeByteNTimes</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=nb>@This</span><span class=p>(),</span><span class=w> </span><span class=n>byte</span><span class=o>:</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>n</span><span class=o>:</span><span class=w> </span><span class=kt>u64</span><span class=p>)</span><span class=w> </span><span class=o>!</span><span class=kt>void</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>So the <code>Reader</code> and <code>Writer</code> wrap an existing method and provide additional ones while
<code>SeekableStream</code> only wraps existing methods.</p><h3 id=streamsource>StreamSource</h3><p>When you write some kind of loaders or parsers you often want to support two ways of doing it. One
way lets the user just specify the file from which to parse the data and another one allows the user
to load the data themselves and then provide the buffer from which to parse.</p><p>Reading a buffer as a stream is provided by a <code>std.io.FixedBufferStream</code> which provides <code>read()</code>,
<code>write()</code> and seek methods and methods to fetch the <code>Reader</code>, <code>Writer</code> and <code>SeekableStream</code> over
that buffer.</p><p>That way if some loader function accepts any reader you can pass it either <code>File.reader()</code> or
<code>FixefBufferStream.reader()</code> and it could work with both. Since those two readers are different type
instances of a generic type that function would need to accept <code>anytype</code> and thus be generic itself.
If it needs to store a reference to that reader then the entire type containing that function would
need to be generic. That can lead to a lot of generated code.</p><p><code>std.io.StreamSource</code> exists to solve that issue for the most common case I explained above. It is a
union that can wrap either a buffer or a file and then provide one streaming API for both in the
form of already described <code>read()</code>, <code>write()</code> and seek methods and methods to fetch the <code>Reader</code>,
<code>Writer</code> and <code>SeekableStream</code>.</p><p>With it you can now write non generic loader functions that either accept the whole <code>StreamSource</code>
or just <code>StreamSource.Reader</code> and they will support reading from either a file or memory buffer, but
it will not, for example, support reading from <code>std.net.Stream</code> in any way.</p><h2 id=analysis>Analysis</h2><p><code>File</code> and <code>std.net.Stream</code> wrap the functionality offered by the operating systems with a simple
and straightforward API so I don&rsquo;t see some room for options there. Maybe some of the methods that
currently only exist on <code>File</code> could make sense for <code>std.net.Stream</code> as well, like <code>readAll</code> and
<code>writeAll</code>, but that is it.</p><p>Now <code>Reader</code>, <code>Writer</code> and <code>SeekableStream</code> seem a bit odd. They look like interfaces but they are
generic types, meaning each underlying stream that wants to provide them needs to define its own
specific type of those generics. That in turn means that any methods that want to receive any
<code>Reader</code> for example, would have to actually receive a parameter of type <code>anytype</code> and then just
assume or check that that type has all the <code>Reader</code> methods it needs. Same goes for the other two
interfaces.</p><p>Having <code>SeekableStream</code> as a separate struct doesn&rsquo;t make sense from a usage point of view. You
never just need a seeking functionality. You need it in combination with reading or writing. If some
method needs a seekable reader it needs to receive <code>anytype</code> <code>Reader</code> and <code>anytype</code>
<code>SeekableStream</code>. Two things that actually refer to the same underlying stream.</p><p>Currently <code>std.io.BufferedReader</code> is implemented in a way where it can wrap any other Reader and
provide buffering additionally but if you then try to use it with a <code>SeekableStream</code> from the
original stream it will not work. <code>BufferedReader</code> itself doesn&rsquo;t provide a way to do the seeking.</p><p>The only reason I see that it is now separated is the fact that some streams support seeking, like
<code>File</code>, while some like <code>std.net.Stream</code> don&rsquo;t and there wasn&rsquo;t an easy way to sometimes create a
<code>Reader</code> with and sometimes without seeking methods. Same goes for the <code>Writer</code>.</p><p>Another oddity of <code>SeekableStream</code> is that it doesn&rsquo;t add any additional behavior. As far as I see
there is really no need for it at all in this form. If any method that needs a <code>SeekableStream</code>
actually needs to receive <code>anytype</code> and then see if it has seek methods we can always just provide
the original stream as a parameter since it will already have those methods. Currently they could be
called differently in the original stream since they are actually passed as <code>comptime</code> parameters to
generic <code>SeekableStream</code> struct but I saw no example where that was actually needed.</p><p>Another important problem of creating these <code>Reader</code>, <code>Writer</code> and <code>SeekableStream</code> abstractions
over different types of streams is that those streams often return different error sets from their
<code>read()</code>, <code>write()</code> and seek methods. Sometimes they don&rsquo;t even return any error at all.</p><p>That is the main reason those abstractions need to remain generic. The only other option is to allow
methods in abstractions to return <code>anyerror</code> and thus lose information about specific possible
errors.</p><h2 id=alternatives>Alternatives</h2><h3 id=1-just-make-seekablestream-a-part-of-reader-and-writer>1. Just make <code>SeekableStream</code> a part of <code>Reader</code> and <code>Writer</code></h3><p>We can easily solve this with the help of mixins. If you don&rsquo;t know what they are or how they work
in Zig you can read my previous <a href=/blog/mixins-in-zig/>post</a>.</p><p>The solution would look something like this for the <code>Reader</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>ReaderMethods</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kr>comptime</span><span class=w> </span><span class=n>Self</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kr>comptime</span><span class=w> </span><span class=n>ReadError</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kr>comptime</span><span class=w> </span><span class=n>readFn</span><span class=o>:</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=p>(</span><span class=n>context</span><span class=o>:</span><span class=w> </span><span class=n>Context</span><span class=p>,</span><span class=w> </span><span class=n>buffer</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=n>ReadError</span><span class=o>!</span><span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>Error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ReadError</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>read</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=n>Self</span><span class=p>,</span><span class=w> </span><span class=n>buffer</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=n>Error</span><span class=o>!</span><span class=kt>usize</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>readFn</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>context</span><span class=p>,</span><span class=w> </span><span class=n>buffer</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// The rest of the Reader methods
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>SeekMethods</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>Self</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>SeekError</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>getReturnErrorType</span><span class=p>(</span><span class=nb>@TypeOf</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>context</span><span class=p>.</span><span class=n>seekBy</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>GetSeekPosError</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>getReturnErrorType</span><span class=p>(</span><span class=nb>@TypeOf</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>context</span><span class=p>.</span><span class=n>getPos</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>seekBy</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=n>Self</span><span class=p>,</span><span class=w> </span><span class=n>amt</span><span class=o>:</span><span class=w> </span><span class=kt>i64</span><span class=p>)</span><span class=w> </span><span class=n>SeekError</span><span class=o>!</span><span class=kt>void</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>self</span><span class=p>.</span><span class=n>context</span><span class=p>.</span><span class=n>seekBy</span><span class=p>(</span><span class=n>amt</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// The rest of seek methods
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>Reader</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kr>comptime</span><span class=w> </span><span class=n>Context</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kr>comptime</span><span class=w> </span><span class=n>ReadError</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kr>comptime</span><span class=w> </span><span class=n>readFn</span><span class=o>:</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=p>(</span><span class=n>context</span><span class=o>:</span><span class=w> </span><span class=n>Context</span><span class=p>,</span><span class=w> </span><span class=n>buffer</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=n>ReadError</span><span class=o>!</span><span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>context</span><span class=o>:</span><span class=w> </span><span class=n>Context</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>const</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@This</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=k>usingnamespace</span><span class=w> </span><span class=n>ReaderMethods</span><span class=p>(</span><span class=n>Self</span><span class=p>,</span><span class=w> </span><span class=n>ReadError</span><span class=p>,</span><span class=w> </span><span class=n>readFn</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// One option is to support seeking here directly if needed:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=k>usingnamespace</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>hasSeekMethods</span><span class=p>(</span><span class=n>Context</span><span class=p>))</span><span class=w> </span><span class=n>SeekMethods</span><span class=p>(</span><span class=n>Self</span><span class=p>)</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// The other option is to provide explicit choice for SeekableReader:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>SeekableReader</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kr>comptime</span><span class=w> </span><span class=n>Context</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kr>comptime</span><span class=w> </span><span class=n>ReadError</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kr>comptime</span><span class=w> </span><span class=n>readFn</span><span class=o>:</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=p>(</span><span class=n>context</span><span class=o>:</span><span class=w> </span><span class=n>Context</span><span class=p>,</span><span class=w> </span><span class=n>buffer</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=n>ReadError</span><span class=o>!</span><span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>context</span><span class=o>:</span><span class=w> </span><span class=n>Context</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>const</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@This</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=k>usingnamespace</span><span class=w> </span><span class=n>ReaderMethods</span><span class=p>(</span><span class=n>Self</span><span class=p>,</span><span class=w> </span><span class=n>ReadError</span><span class=p>,</span><span class=w> </span><span class=n>readFn</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=k>usingnamespace</span><span class=w> </span><span class=n>SeekMethods</span><span class=p>(</span><span class=n>Self</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Note that I am not passing seek methods explicitly like <code>SeekableStream</code> currently does since, as I
said, I didn&rsquo;t find an example where they are called differently and can&rsquo;t be used directly. If
there are other reasons to do that then we would need to go with the second option and pass another
six parameters that <code>SeekableStream</code> now receives.</p><p>If we don&rsquo;t pass those methods we should probably add checks that Context does contain seek methods
and report a nice <code>@compileError</code> if it doesn&rsquo;t.</p><p>Currently <code>BufferedReader</code> is defined like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>BufferedReader</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>buffer_size</span><span class=o>:</span><span class=w> </span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=kr>comptime</span><span class=w> </span><span class=n>ReaderType</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Just like above we can make <code>BufferedSeekMethods</code> mixin and mix it in only if <code>ReaderType</code> has seek
methods. That way if passed in <code>ReaderType</code> has seek methods so will its <code>BufferedReader</code>. That is
one problem solved.</p><p>Additionally this would make it easy to write the <code>StreamSource</code> so that it wraps
<code>File.BufferedReader</code> instead of <code>File</code> directly.</p><p>Another thing we can do is add something like this to the <code>Reader</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>readerInterfaceId</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@typeName</span><span class=p>(</span><span class=n>Context</span><span class=p>)</span><span class=w> </span><span class=o>++</span><span class=w> </span><span class=s>&#34;.Reader&#34;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>If some method wants to check if the <code>anytype</code> parameter passed to it is a <code>Reader</code> it can just
check if it <code>@hasDecl(ReaderType, "readerInterfaceId")</code> and the value of that field could maybe be
used in some <code>@compileError</code> messages. <code>SeekMethods</code> mixin could additionally add another
<code>seekableIntefaceId</code> so we can use the same method to check if it also has seek methods.</p><p>The other problems coming from these being generic types remain but they might be insignificant.</p><p>Migrating the standard library and existing code to this solution shouldn&rsquo;t be too hard. Mostly it
would involve deleting <code>SeekableStream</code> and its usages and std lib isn&rsquo;t using it anyway.</p><h3 id=2-use-vtable-interface-like-allocator>2. Use VTable interface like Allocator</h3><p>Allocator is an interface to any concrete allocator implementation but it isn&rsquo;t a generic type. It
is a plain struct that contains an opaque pointer to the actual allocator and a vtable struct with
pointers to internal wrapping methods that also receive an opaque pointer as first parameter. Some
comptime magic is only used to generate those internal wrapping methods so they cast that first
parameter to the type of each concrete allocator implementation before calling its own method.</p><p>Allocator struct then also provides additional common utility methods that use some of the basic
three that must be provided by the implementation: alloc, free and resize. So this method still
allows adding additional behavior.</p><p>Now all allocator implementations can only return one error from their <code>alloc()</code> method and that is
<code>OutOfMemory</code>. That allows this single <code>Allocator</code> struct to have a wrapping method that also can
return just this error and still be the common interface for any concrete implementation.</p><p>As already mentioned, different streams return different kinds of errors from their <code>read</code>, <code>write</code>
and seek methods so the only way this pattern could work is if the common interfaces return
<code>anyerror</code>. That also means that any library function that works with a <code>Reader</code> or <code>Writer</code> also
needs to return <code>anyerror</code> thus losing the ability to document and help its user properly handle its
specific errors.</p><p>EDIT:</p><p>I could not find a way to to make anything useful of this solution but @InKrypton made a comment
that if we define a VTable that is generic only over errors something like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>Writer</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>WriteError</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>const</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@This</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>p_context</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>anyopaque</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>writeFn</span><span class=o>:</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=n>anyopaque</span><span class=p>,</span><span class=w> </span><span class=p>[]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=n>Error</span><span class=o>!</span><span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>Error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>WriteError</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>init</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kr>comptime</span><span class=w> </span><span class=n>T</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>p_ctx</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>T</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kr>comptime</span><span class=w> </span><span class=n>writeFn</span><span class=o>:</span><span class=w> </span><span class=k>fn</span><span class=p>(</span><span class=o>*</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=p>[]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=n>Error</span><span class=o>!</span><span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>)</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kr>const</span><span class=w> </span><span class=n>gen</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>fn</span><span class=w> </span><span class=n>write</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>ptr</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>anyopaque</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>bytes</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>)</span><span class=w> </span><span class=n>Error</span><span class=o>!</span><span class=kt>usize</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>return</span><span class=w> </span><span class=n>writeFn</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=nb>@ptrCast</span><span class=p>(</span><span class=o>*</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=nb>@alignCast</span><span class=p>(</span><span class=nb>@alignOf</span><span class=p>(</span><span class=n>T</span><span class=p>),</span><span class=w> </span><span class=n>ptr</span><span class=p>)),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>bytes</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>Self</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=n>p_context</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p_ctx</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=n>writeFn</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>gen</span><span class=p>.</span><span class=n>write</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>write</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=n>Self</span><span class=p>,</span><span class=w> </span><span class=n>bytes</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=n>Error</span><span class=o>!</span><span class=kt>usize</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>self</span><span class=p>.</span><span class=n>writeFn</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>p_context</span><span class=p>,</span><span class=w> </span><span class=n>bytes</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// The rest of write methods
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>That can enable us to write functions that need to receive any writer like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=k>fn</span><span class=w> </span><span class=n>foo</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kr>comptime</span><span class=w> </span><span class=n>WriteErr</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>writer</span><span class=o>:</span><span class=w> </span><span class=n>std</span><span class=p>.</span><span class=n>io</span><span class=p>.</span><span class=n>Writer</span><span class=p>(</span><span class=n>WriteErr</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=n>WriteErr</span><span class=o>!</span><span class=kt>void</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>So instead of receiving <code>anytype</code> we can actually say that it needs to receive a <code>Writer</code> and we
just need to specify what errors that <code>Writer</code> can return. This makes the API clearer and doesn&rsquo;t
require any additional checks on what methods are available.</p><p>We should be able to still apply the solution from the previous point to merge <code>SeekableStream</code> into
<code>Reader</code> and <code>Writer</code> interfaces that are defined like this.</p><p>Migrating to this solution would require a bit more work but shouldn&rsquo;t be complicated to do.</p><h3 id=3-make-streams-be-readers-and-writers-using-mixins>3. Make streams be Readers and Writers using mixins</h3><p>Again if you don&rsquo;t know what mixins are or how they are done in Zig you can read about it <a href=/blog/mixins-in-zig/>here</a>.</p><p>In this approach there would not be a separate <code>Reader</code>, <code>Writer</code> and <code>SeekableStream</code>. There would
just be <code>ReaderMethods</code> and <code>WriterMethods</code> mixins that provide that common additional methods that
currently <code>Reader</code> and <code>Writer</code> provide. Something like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>ReaderMethods</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>Self</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Now the provided Self type needs to provide the read method
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=nb>@hasDecl</span><span class=p>(</span><span class=n>Self</span><span class=p>,</span><span class=w> </span><span class=s>&#34;read&#34;</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>@compileError</span><span class=p>(</span><span class=s>&#34;Expected a read(*&#34;</span><span class=w> </span><span class=o>++</span><span class=w> </span><span class=nb>@typeName</span><span class=p>(</span><span class=n>Self</span><span class=p>)</span><span class=w> </span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=s>&#34;, []const u8) !usize method in &#34;</span><span class=w> </span><span class=o>++</span><span class=w> </span><span class=nb>@typeName</span><span class=p>(</span><span class=n>Self</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kr>const</span><span class=w> </span><span class=n>ReadError</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>getReturnErrorType</span><span class=p>(</span><span class=nb>@TypeOf</span><span class=p>(</span><span class=n>Self</span><span class=p>.</span><span class=n>read</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>@TypeOf</span><span class=p>(</span><span class=n>Self</span><span class=p>.</span><span class=n>read</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=k>fn</span><span class=p>(</span><span class=o>*</span><span class=n>Self</span><span class=p>,</span><span class=w> </span><span class=p>[]</span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=n>ReadError</span><span class=o>!</span><span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>@compileError</span><span class=p>(</span><span class=s>&#34;Expected a read &#34;</span><span class=w> </span><span class=o>++</span><span class=w> </span><span class=nb>@typeName</span><span class=p>(</span><span class=k>fn</span><span class=p>(</span><span class=o>*</span><span class=n>Self</span><span class=p>,</span><span class=w> </span><span class=p>[]</span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=n>ReadError</span><span class=o>!</span><span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=s>&#34; method in &#34;</span><span class=w> </span><span class=o>++</span><span class=w> </span><span class=nb>@typeName</span><span class=p>(</span><span class=n>Self</span><span class=p>)</span><span class=w> </span><span class=o>++</span><span class=w> </span><span class=s>&#34; but got &#34;</span><span class=w> </span><span class=o>++</span><span class=w> </span><span class=nb>@typeName</span><span class=p>(</span><span class=nb>@TypeOf</span><span class=p>(</span><span class=n>Self</span><span class=p>.</span><span class=n>read</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>readAll</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=n>Self</span><span class=p>,</span><span class=w> </span><span class=n>buffer</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=n>Error</span><span class=o>!</span><span class=kt>usize</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kr>var</span><span class=w> </span><span class=n>index</span><span class=o>:</span><span class=w> </span><span class=kt>usize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>index</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>buffer</span><span class=p>.</span><span class=n>len</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kr>const</span><span class=w> </span><span class=n>amt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>try</span><span class=w> </span><span class=n>self</span><span class=p>.</span><span class=n>read</span><span class=p>(</span><span class=n>buffer</span><span class=p>[</span><span class=n>index</span><span class=p>..]);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>amt</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>index</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>index</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>amt</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>index</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// The rest of the Reader methods
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>File</code> and <code>std.net.Stream</code> would now mixin those methods into their own implementation and <code>File</code>
would still have those additional seeking methods. Functions that need to receive &lsquo;some seekable
reader&rsquo; for example, would provide one argument of type <code>anytype</code> and just like now check if all the
methods needed, both reading and seeking, are defined on the given type.</p><p>We could use the trick I mentioned in the first alternative, where <code>ReaderMethods</code> also define</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>readerInterfaceId</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@typeName</span><span class=p>(</span><span class=n>Self</span><span class=p>)</span><span class=w> </span><span class=o>++</span><span class=w> </span><span class=s>&#34;.Reader&#34;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>so that checking if some <code>ReaderType: anytype</code> is a reader can be done like this</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>@hasDecl</span><span class=p>(</span><span class=n>ReaderType</span><span class=p>,</span><span class=w> </span><span class=s>&#34;readerInterfaceId&#34;</span><span class=p>))</span><span class=w> </span><span class=p>...</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>For that purpose we could also define <code>SeekerMethods()</code> mixin that only checks if the given <code>Self</code>
type has all the seek methods and only mixes in</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=kr>pub</span><span class=w> </span><span class=kr>const</span><span class=w> </span><span class=n>seekInterfaceId</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@typeName</span><span class=p>(</span><span class=n>Self</span><span class=p>)</span><span class=w> </span><span class=o>++</span><span class=w> </span><span class=s>&#34;.Seeker&#34;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>and doesn&rsquo;t add any new methods.</p><p><code>BufferedReader</code> would provide its own <code>read()</code> method that wraps the original one with additional
logic just like now and would also mixin <code>ReaderMethods</code>. If the passed in reader has seek methods
it could also wrap those using something like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=kr>pub</span><span class=w> </span><span class=k>usingnamespace</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>@hasDecl</span><span class=p>(</span><span class=n>ReaderType</span><span class=p>,</span><span class=w> </span><span class=s>&#34;seekInterfaceId&#34;</span><span class=p>))</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Seek methods go here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{};</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>In this approach there is even less indirection than in the current implementation and it is also
easy to implement and use. Methods that receive them as arguments being generic as in the current
solution would also generate similar amounts of code.</p><p>One issue with this approach is that the struct that wants to use these mixins must have a read
method with this exact signature:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=n>read</span><span class=p>(</span><span class=n>self</span><span class=o>:</span><span class=w> </span><span class=o>*</span><span class=n>Self</span><span class=p>,</span><span class=w> </span><span class=n>buffer</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=n>SomeError</span><span class=o>!</span><span class=kt>usize</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Same goes for the <code>write()</code> method. Both <code>File</code> and <code>std.net.Stream</code> do have that but currently in
std lib we also have:</p><ol><li><code>std.fifo.LinearFifo</code> which has a <code>read</code> method whose return type is just <code>usize</code> and not an
error union and so for the current <code>Reader</code> it defines a separate method called <code>readFn</code> that
just calls <code>read</code> but returns an error union with empty error set like this <code>error{}!usize</code>.</li><li><code>std.os.uefi.protocols.FileProtocol</code> that has a <code>read</code> method with a bit different signature and
then it also defines a separate <code>readFn</code> method for the <code>Reader</code> that has the proper signature
and marshals the call to the actual <code>read</code>.</li></ol><p>Note that the reason they must have a <code>read()</code> method that returns error union is not the check we
added in <code>ReaderMethods</code> mixin but the fact that code that uses &ldquo;any reader&rdquo; might always call <code>try reader.read(...)</code> and the <code>try</code> statement will not compile unless <code>read()</code> returns an error union.</p><p>I am not sure how acceptable it would be to change the main <code>read()</code> method in those structs to
align with the <code>Reader</code> interface and then provide their current <code>read()</code> method under a different
name.</p><p>Migrating existing code to this alternative also wouldn&rsquo;t be too hard and would mostly involve
deleting code. We would need to delete all <code>reader()</code>, <code>writer()</code> and <code>seekableStream()</code> methods and
probably just replace their calls with the object they were called on. For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=n>ImageLoader</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>someStream</span><span class=p>.</span><span class=n>reader</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// would just become
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>ImageLoader</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>someStream</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// and in case Image Loader was receiving StreamSource it would remain the same:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ImageLoader</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>someStreamSource</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>StreamSource</code> in this alternative would still wrap <code>read()</code>, <code>write()</code> and seek methods just like
now and also mixin the <code>ReadMethods</code>, <code>WriteMethods</code> and <code>SeekMethods</code>.</p><h2 id=conclusion>Conclusion</h2><p>Although the second alternative looked to be unusable the @InKrypton&rsquo;s suggestion made it a valid
solution. This solution probably does the most to make the APIs of the functions as clear as
possible. It has a bit more indirection and it did&rsquo;t completely remove generics but it made them
more ergonomic.</p><p>The first alternative that just merges <code>SeekableStream</code> into <code>Reader</code> and <code>Writer</code> seems to me like
a clear improvement with no downsides over the existing solution. I think that part is something we
should do no matter what we decide on the rest of suggestions.</p><p>Personally I like the third alternative the most. It gives the most potential for clearing up both
the stream implementations and their usage code. I am just not sure how acceptable it is to require
that every stream implements the exact <code>read()</code> and <code>write()</code> methods that are required by the
interfaces.</p><p>What do you think? Do you have some further arguments to provide over some solution? Or maybe you
have an idea for some new solution? Join us on
<a href=https://forum.ziggit.dev/t/redesigning-zig-io-api/210>Ziggit</a> forum and share your opinion.</p><footer class=footline></footer></article></div></main></div><aside id=sidebar class="default-animation showVisitedLinks"><div id=header-wrapper class=default-animation><div id=header class=default-animation><a id=logo href=/><img src=/images/logo.svg alt=Author></a></div><div class="searchbox default-animation"><label for=search-by><i class="fas fa-search"></i></label>
<input data-search-input id=search-by type=search placeholder=Search...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script>var contentLangs=["en"]</script><script src=/js/auto-complete.js?1667939627></script>
<script src=/js/lunr.min.js?1667939627></script>
<script src=/js/lunr.stemmer.support.min.js?1667939627></script>
<script src=/js/lunr.multi.min.js?1667939627></script>
<script src=/js/lunr.en.min.js?1667939627></script>
<script src=/js/search.js?1667939627></script></div><div id=content-wrapper class=highlightable><ul class="topics collapsible-menu"><li data-nav-id=/blog/ title=Blog class="dd-item parent alwaysopen"><input type=checkbox id=section-b57fa9e78d8a8d44279b9b64514df241 class=toggle checked><label for=section-b57fa9e78d8a8d44279b9b64514df241></label><a href=/blog/>Blog<i class="fas fa-check read-icon"></i></a><ul><li data-nav-id=/blog/redesigning-zig-io-api/ title="Redesigning Zig IO Api" class="dd-item active"><a href=/blog/redesigning-zig-io-api/>Redesigning Zig IO Api<i class="fas fa-check read-icon"></i></a></li></ul></li></ul><div id=shortcuts><div class=nav-title>More</div><ul><li><a class=padding href=/more/about-me/><i class='fas fa-address-card'></i> About me</a></li><li><a class=padding href=https://github.com/igor84/><i class='fab fa-fw fa-github'></i> GitHub profile</a></li><li><a class=padding href=https://twitter.com/igorst><i class='fab fa-fw fa-twitter'></i> Twitter</a></li><li><a class=padding href=https://mastodon.gamedev.place/@driggy rel=me><i class='fab fa-fw fa-mastodon'></i> Mastodon</a></li><li><a class=padding href=/tags/><i class='fas fa-fw fa-tags'></i> Tags</a></li></ul></div><div class="footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showVisitedLinks showFooter"></div><hr class="default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showVisitedLinks showFooter"><div id=prefooter class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch showVisitedLinks"><ul><li id=select-language-container class=footerLangSwitch><a class="padding select-container"><i class="fas fa-language fa-fw"></i>
<span>&nbsp;</span><div class=select-style><select id=select-language onchange="location=baseUri+this.value"></select></div><div class=select-clear></div></a></li><li id=select-variant-container class="footerVariantSwitch showVariantSwitch"><a class="padding select-container"><i class="fas fa-paint-brush fa-fw"></i>
<span>&nbsp;</span><div class=select-style><select id=select-variant onchange=variants.changeVariant(this.value)><option id=relearn-dark value=relearn-dark selected>Relearn Dark</option><option id=neon value=neon>Neon</option><option id=relearn-light value=relearn-light>Relearn Light</option></select></div><div class=select-clear></div></a><script>variants.markSelectedVariant()</script></li><li class="footerVisitedLinks showVisitedLinks"><a class=padding href=# data-clear-history-toggle><i class="fas fa-history fa-fw"></i> Clear History</a></li></ul></div><div id=footer class="footerFooter showFooter"><p>Built with <a href=https://github.com/McShelby/hugo-theme-relearn><i class="fas fa-heart"></i></a> by <a href=https://gohugo.io/>Hugo</a></p></div></div></aside><script src=/js/clipboard.min.js?1667939627></script>
<script src=/js/perfect-scrollbar.min.js?1667939627></script>
<script src=/js/featherlight.min.js?1667939627></script>
<script src=/js/theme.js?1667939627></script></body></html>