[{"content":"Welcome to Dr Iggy’s coding adventures ","description":"","tags":null,"title":"Dr Iggy's Coding Adventures","uri":"/"},{"content":"","description":"","tags":null,"title":"png","uri":"/tags/png/"},{"content":"Although there is already a solid zigimg image loading library it didn’t quite tick all the checkboxes for me. It doesn’t provide the flexibility that I am aiming for and it is using far more allocations than is necessary. Also since I already wrote a png reader in DLang it felt like a good project for learning zig to try to reimplement it and try to improve on my original design.\nYou can find the solution I came up with here. In order to understand my design we first need to know a bit about the png format. The Png file is a sequence of chunks of different types. Each chunk has a 4 byte id, represented as 4 ascii letters. Some examples are:\n IHDR for a header chunk that contains things like width, height and pixel format PLTE for a palette chunk in case pixels are stored as indices into that palette tRNS for a chunk that says what color should be considered as transparent  The specification says that if the first letter of the id is upper case it is a critical chunk that the reader must know how to parse. Otherwise the chunk is optional and the image can be displayed without parsing it but it might not be displayed completely as intended.\nSo my idea was to create a reader that can parse critical chunks and allow users to register parsers for any number of optional chunks. It would also come with some chunk parsers implemented but in such a way that they are not even compiled in if they are not used. I didn’t quite manage to accomplish that in the first version I wrote in DLang but I am pretty happy with what I managed to write so far in Zig.\nThis is the API I came up with so far:\nconstfile=trycwd.openFile(\"image.png\",.{.mode=.read_only});varreader=pngreader.fromFile(file);varheader=tryreader.loadHeader();varpixelData=reader.loadWithHeader(\u0026header,allocator,options);In case you already have the whole file loaded into memory you can also use pngreader.fromMemory(u8buffer);. Also if you don’t want to handle the header separately but just load the image you can just call reader.load(allocator, options).\nThe key to the design is, of course, the options argument. Its type is defined like this:\npubconstReaderOptions=struct{temp_allocator:Allocator,processors:[]ReaderProcessor=\u0026[_]ReaderProcessor{},};It provides a way for you to specify a separate allocator that will be used for temporary allocations during loading and it is bounded to 800KiB at the moment but I hope to reduce it in the future. The other thing is a slice of processors for different chunk types. Each ReaderProcessor has an id which says what chunk type it is dedicated to and it provides processChunk and optional processPalette and processDataRow functions. It is actually an interface to specific implementation just like Allocator struct represents a common interface for different implementations of allocators. You can register a processor for critical or optional chunk but in case of optional chunks it will be a responsibility of its processChunk function to read in or seek over the bytes of its chunk from underlining stream reader while for critical chunks it must not do that but just use the passed in data. The other two methods allow each processor to affect the palette or pixel data as they are loaded using the info they parsed.\nCurrently the reader comes with two processors implemented: TrnsProcessor and PlteProcessor.\nTrnsProcessor will parse the tRNS chunk if it exists and extract what colors should be considered transparent. It will then add an alpha channel to the image format and place that info there. So if the image is in Grayscale format it will become GrayscaleAlpha and if it is in RGB format it will become RGBA and in the alpha channel 0 will be written for a color that needs to be considered transparent and 255 for others.\nPlteProcessor, if the image is in Indexed format will change that to RGB format and will convert pixel data so that instead of palette indices it contains the actual RGB values from the palette directly. Note that if you also use TrnsProcessor and the tRNS chunk also exists the final format will be RGBA since it will also add an alpha channel.\nSo if you just pass a default for the options argument:\nvarpixelData=reader.loadWithHeader(\u0026header,allocator,.{});no processors will be used or compiled in and a static buffer on stack will be used for temporary allocations. If you want to use default options that include the above two processors you can just do this:\nvardef_options=DefOptions{};varpixelData=reader.loadWithHeader(\u0026header,allocator,def_options.get());It will also use a stack buffer for temporary allocations but it will use both of the above processors.\nIn case you implement additional processors, for example for sRGB and cHRM chunks you could call it with them like this:\nvartrns=TrnsProcessor{};varplte=PlteProcessor{};varsrgb=SrgbProcessor{};varchrm=ChrmProcessor{};varprocessors=[_]ReaderProcessor{trns.processor(),plte.processor(),srgb.processor(),chrm.processor(),};vartmp_buffer:[800*1024]u8=undefined;varfb_allocator=std.heap.FixedBufferAllocator.init(tmp_buffer[0..]);varoptions=ReaderOptions.initWithProcessors(fb_allocator.allocator(),processors[0..]);Also if you want to use these as default throughout your project you can just define a struct called DefPngOptions in your root file in the same way DefOptions struct is defined in the reader.\nThe API for non default options is a bit verbose because you need to provide the place for all the pieces. In the above case they are all on stack. On the other hand I made default usage as simple as I could and I also provided more flexibility than any other png loader I found without sacrificing its memory efficiency or performance.\nI hope to cover a bit about how I handle the memory in a separate post. Until then happy Zigging!\n","description":"","tags":["zig","png"],"title":"Png Reader in Zig","uri":"/blog/png-reader-in-zig/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/tags/"},{"content":"","description":"","tags":null,"title":"zig","uri":"/tags/zig/"},{"content":"","description":"","tags":null,"title":"engine","uri":"/tags/engine/"},{"content":"","description":"","tags":null,"title":"game","uri":"/tags/game/"},{"content":"I am doing programming for 24 years now and I don’t see myself getting bored with it. There is always one more thing to learn or to solve and I really want to know everything .\nThe goal I am most interested in is making my own game engine. But I don’t want to take the SDL library, some image and 3D data loading library and just write rendering logic. I want to learn how it all works.\nI want to know how windowing is done on different platforms, how inputs are processed, how sound is produced, how images or sounds or 3D models are parsed and loaded. I want to know every little thing that comes on the way.\nI don’t care that I will never get done. I don’t care if in 10 years I am still scratching the surface. As long as I am learning something new I am happy.\nObstacles I do have to confess it is easy to get sidetracked. I want to write the png loader, but for that I need a decompression library which needs an Adler hashing algorithm. I would check if there are good implementations of those in the language I am working on but if for any reason I am not happy about that implementation or I find someone wrote a better one in another language I want to port that or write a new one that is to my liking.\nSometimes I realize I am not happy with the language I chose so I would investigate others until I find a new pet. Or if I don’t find anything at the moment I might even try to write a compiler for my own language. At some point I also realize the path I took doesn’t hold my interest any more so I would go back and just choose some other path. Something interesting to learn is everywhere.\nIt also surprised me how often the things I learned turned out useful in my job even though I chose my hobbies to be different. On the other hand, I specifically chose not to go into making my own operating system. It would be too much removed from my daily work and I do have my limits.\nBesides all of this I always have motivation to play some games or watch movies or read books but about that some other time.\n","description":"","tags":["personal","game","engine"],"title":"How do I stay motivated","uri":"/blog/how-do-i-stay-motivated/"},{"content":"","description":"","tags":null,"title":"personal","uri":"/tags/personal/"},{"content":"","description":"","tags":null,"title":"Blog","uri":"/blog/"},{"content":"What is the closest thing in this world to magic?\nTo me it will always be programming. You type in some incantations and stuff happens :).\nHere I want to document and share my explorations into this magic world. My most recent trip went into Zig land so most of the articles will talk about that.\nBut who am I? I got my first PC in 1997, when I was 13 years old and got my hands on my first programming language somewhere in 1998. It was QBasic and I created some of the first games and programs in it. I wrote Hangman, Mastermind, Breakout and even did something like a Paint program.\nI shortly switched to Pascal and then jumped to Delphi (or Object Pascal). There I learned about SDL library and OpenGL and did a clone of Nintendo’s Battle city game.\nWhile doing that I realized how hard it is to create UI for a game, especially compared to Delphi which I consider is still unmatched in ease of use for creating desktop UIs. So, as I was finishing high school, I wrote a UI library called SDLControls for Object Pascal.\nDuring high school I also learned a bit about assembler and how CPUs work on a lower level. It was fascinating at the time.\nAs college started I lost my free time and didn’t do much outside of school projects which included Pascal, C, Java, C# and PHP. Straight from college I started working on Java bussiness software in 2007. During the next four years I would move from the first company, to the second and third until in 2011 I got a job at a startup gaming company. One of the first in my country.\nThe company was a success and 11 years later I am still working there doing my dream job. Suprisingly, for my younger self it turned out not to be making games itself, but rather making tools for making games .\nI started on some web applications with PHP and Javascript and then moved to Unity and C#. But that fascination about inner workings of the PC from younger days is still burning in me so I still find some side projects to play with in my free time.\nCasey Muratory with his Handmade Hero series series and Jonathan Blow with his talk about a custom compiler were a great inspiration. Thanks to them I refreshed my C knowledge and wrote a tiny compiler, Summus, as a sort of introduction to writing one using LLVM as a backend.\nI then learned what I could about other new languages and among Rust, Go, Nim and DLang I chose the latter as most intuitive and powerful language. Coming from Unity and C# DLang seemed like a perfect language for a Game Engine. It supports garbage collection but also manual memory management so it seemed like I could use it to write both low level systems and later use as gameplay logic language as well. No need for separate scripting language.\nUnfortunatelly I got dissapointed with some drawbacks of the language and the fact that its leadership didn’t seem very interested to work on those things. At the time Odin and Zig also came under my reader and so I decided to play with Zig and document my journey here.\nAnd so here we are!\n","description":"","tags":null,"title":"About Me","uri":"/more/about-me/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/categories/"}]